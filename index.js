const Module = require('module')
const hooks = {}
const hookObject = {addHook, getHooks, removeHook}

let originalRequire = undefined

//
// Public require replacement function.
//

/**
 * Replaces the require function and calls all the hooked functions.
 *
 * @param {String} path
 *
 * @return {*}
 */
function requireReplacement(path) {
    let resolved = false
    let resolvedValue = undefined
    let resolvePath = undefined

    /**
     * The resolver function.
     *
     * @param {*} newValue  New require path.
     * @param {Boolean} returnNewValue  If true, will use newValue as the export.
     */
    const resolve = (newValue = undefined, returnNewValue = false) => {
        resolved = true

        // If newValue is undefined and returnNewValue is false, will use the original path for require.
        if (newValue === undefined && !returnNewValue) {
            resolvePath = path
            
            return true
        }

        // Will use newValue as the export.
        if (returnNewValue) {
            resolvedValue = newValue
            
            return true
        }

        // If the new path is not a string, will return false.
        if (typeof newValue != 'string') {
            return false
        }
        
        // A new path will be used for require.
        resolvePath = newValue
        
        return true
        
    }
    
    Object.keys(hooks).forEach(key => {
        hooks[key](path, resolved ? undefined : resolve)
    })

    if (resolved) {
        if (resolvePath) {
            return Module._load(resolvePath, this, false)
        }

        return resolvedValue
    }
}

//
// hookObject.
//

/**
 * Adds a hook.
 *
 * @param {Function} hook
 *
 * @return {String|Undefined}
 */
function addHook(hook) {
    if (typeof hook == 'function') {
        let key = generateKey()

        hooks[key] = hook
        requireReplaceSet()

        return key
    }

    return false
}

//
// Private.
//

/**
 * Returns all the hooks.
 *
 * @return {Object}
 */
function getHooks() {
    return hooks
}

/**
 * Removes a hook.
 *
 * @param {String} key
 *
 * @return {Boolean}
 */
function removeHook(key) {
    if (hooks[key]) {
        requireReplaceRemove()
        delete hooks[key]

        return true
    }

    return false
}

/**
 * Generates a unique key.
 *
 * @return {String}
 */
function generateKey() {
    let key = String(Math.random())

    if (hooks[key]) {
        return generateKey()
    }

    return key
}

/**
 * Replaces the require function if atleast one hook is set.
 */
function requireReplaceSet() {
    if (Object.keys(hooks).length === 1) {
        originalRequire = Module.prototype.require
        Module.prototype.require = requireReplacement
    }
}

/**
 * Restores the require function if atleast one hook is set.
 */
function requireReplaceRemove() {
    if (Object.keys(hooks).length === 1) {
        Module.prototype.require = originalRequire
        originalRequire = undefined
    }
}

/**
 * The main interface of require-hook.
 *
 * @param {*} hook
 * @param {*} scope
 * 
 * @return {Boolean|Object}
 */
module.exports = (hook, scope) => {
    // Hook and scope must of type function in order to run the scoped hooking.
    if (typeof hook == 'function' && typeof scope == 'function') {
        let key = hookObject.addHook(hook)
        let scopeError = undefined
        let scopeReturn = undefined

        // Catches the error generated by scope in order to safely remove the requireHook.
        try {
            scopeReturn = scope()
        } catch(error) {
            scopeError = error
        }

        // If scopeReturn is a Promise, will wait removing the hook until it is resolved/rejected.
        if (scopeReturn instanceof Promise) {
            // throw Error(scopeReturn.finally)
            scopeReturn
                .then(() => hookObject.removeHook(key))
                .catch(() => hookObject.removeHook(key))

            return true
        }

        // Will immediately remove the hook after the scope is finished.
        hookObject.removeHook(key)

        // If scope has thrown an error, will re-throw the catched error.
        if (scopeError) {
            throw scopeError
        }

        return true
    }

    // Returns hookObject if either hook or scope are not of type function.
    return hookObject
}
